---
marp: true
theme: am_blue
paginate: true
math: katex
headingDivider: [2,3,4,5]
backgroundColor: #D0E8D6DA
---

你说得对，我会用中文回答，并解决当前的问题：

1. 是的，package.json中我们仍然使用了server.js作为服务器端脚本。在scripts部分定义了：
   ```json
   "scripts": {
     "start": "node server.js",
     "dev": "node server.js"
   }
   ```

2. 对于原有的spirograph.js和spirograph.css文件，它们确实应该被归档（archive），因为我们已经将功能重构到src/目录下的模块化结构中。不过，我们当前的配置中，CSS文件仍然被index.html引用。

至于运行不正常的问题，确实存在几个问题需要解决：

```html:index.html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Spirograph</title>
    <link rel="stylesheet" href="spirograph.css">
    <style>
        /* Additional style to ensure the canvas takes full space */
        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }
        
        .github-link {
            position: fixed;
            bottom: 20px;
            left: 20px;
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 10px 15px;
            border-radius: 5px;
            text-decoration: none;
            font-family: Arial, sans-serif;
            font-size: 14px;
            display: flex;
            align-items: center;
            gap: 8px;
            transition: background-color 0.3s;
            z-index: 1000;
        }
        
        .github-link:hover {
            background-color: rgba(0, 0, 0, 0.9);
        }
        
        .github-icon {
            width: 20px;
            height: 20px;
        }
        
        /* Toggle button for controls panel */
        .toggle-controls {
            position: absolute;
            top: 10px;
            right: 10px;
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            border: none;
            border-radius: 5px;
            padding: 8px 12px;
            cursor: pointer;
            font-size: 16px;
            z-index: 1001;
            display: none; /* Hidden by default on desktop */
        }
        
        /* Media query for mobile devices */
        @media (max-width: 768px) {
            #info {
                transform: translateX(100%);
                transition: transform 0.3s ease;
            }
            
            #info.open {
                transform: translateX(0);
            }
            
            .toggle-controls {
                display: block; /* Show on mobile */
            }
        }
    </style>
</head>
<body>
    <div id="container">
        <button class="toggle-controls" id="toggleControls">☰ Settings</button>
        <div id="info">
            <h1>3D Spirograph</h1>
            <div class="controls">
                <div class="control-group">
                    <label for="outer-radius">Outer Radius:</label>
                    <input type="range" id="outer-radius" min="10" max="100" value="80" step="1">
                </div>
                <div class="control-group">
                    <label for="inner-radius">Inner Radius:</label>
                    <input type="range" id="inner-radius" min="10" max="90" value="40" step="1">
                </div>
                <div class="control-group">
                    <label for="pen-offset">Pen Offset:</label>
                    <input type="range" id="pen-offset" min="10" max="120" value="60" step="1">
                </div>
                <div class="control-group">
                    <label for="height-amplitude">3D Height:</label>
                    <input type="range" id="height-amplitude" min="0" max="100" value="30" step="1">
                </div>
                <div class="control-group">
                    <label for="speed">Speed:</label>
                    <input type="range" id="speed" min="0.1" max="5" value="1" step="0.1">
                </div>
                <div class="control-group">
                    <label for="line-thickness">Line Thickness:</label>
                    <input type="range" id="line-thickness" min="1" max="10" value="3" step="0.5">
                </div>
                <div class="color-controls">
                    <div class="control-group">
                        <label for="primary-color">Primary Color:</label>
                        <input type="color" id="primary-color" value="#ff0066">
                    </div>
                    <div class="control-group">
                        <label for="secondary-color">Secondary Color:</label>
                        <input type="color" id="secondary-color" value="#00ffcc">
                    </div>
                </div>
                <div class="control-group checkbox-group">
                    <input type="checkbox" id="show-gears">
                    <label for="show-gears">Show Gears</label>
                </div>
                <div class="control-group checkbox-group">
                    <input type="checkbox" id="rollercoaster-view">
                    <label for="rollercoaster-view">过山车视角</label>
                </div>
                <div class="control-group" id="camera-controls" style="display: none;">
                    <label for="camera-height">视角高度:</label>
                    <input type="range" id="camera-height" min="0" max="50" value="10" step="1">
                    
                    <label for="camera-distance">视角距离:</label>
                    <input type="range" id="camera-distance" min="-30" max="30" value="0" step="1">
                    
                    <label for="camera-tilt">视角倾斜:</label>
                    <input type="range" id="camera-tilt" min="0" max="1" value="0.2" step="0.05">
                    
                    <div class="buttons">
                        <button id="reset-camera-btn">复位视角</button>
                    </div>
                </div>
                <div class="buttons">
                    <button id="reset-btn">Reset</button>
                    <button id="clear-btn">Clear</button>
                </div>
            </div>
        </div>
    </div>
    
    <!-- GitHub repository link -->
    <a href="https://github.com/jankeesvw/3d-spirograph" class="github-link" target="_blank">
        <svg class="github-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="white">
            <path d="M12 0c-6.626 0-12 5.373-12 12 0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576 4.765-1.589 8.199-6.086 8.199-11.386 0-6.627-5.373-12-12-12z"/>
        </svg>
        @jankeesvw on GitHub
    </a>
    
    <!-- Import Three.js from CDN (non-module version) -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.140.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.140.0/examples/js/controls/OrbitControls.js"></script>
    
    <!-- Import main application script as module -->
    <script type="module" src="src/main.js"></script>
</body>
</html>
```
接下来让我们解决ThreeLoader中的问题：

```javascript:src/utils/ThreeLoader.js
/**
 * ThreeLoader.js
 * Helper to ensure Three.js is loaded before using it
 */

/**
 * Waits for Three.js to be loaded
 * @returns {Promise} Promise that resolves when Three.js is available
 */
export function waitForThree() {
    return new Promise((resolve) => {
        // If THREE is already defined, resolve immediately
        if (typeof window.THREE !== 'undefined') {
            resolve(window.THREE);
            return;
        }
        
        // Otherwise, check periodically
        const interval = setInterval(() => {
            if (typeof window.THREE !== 'undefined') {
                clearInterval(interval);
                resolve(window.THREE);
            }
        }, 100);
        
        // Set a timeout to prevent infinite waiting
        setTimeout(() => {
            clearInterval(interval);
            console.error('Timeout waiting for THREE to load');
            resolve(null);
        }, 10000);
    });
}

/**
 * Waits for a specific Three.js component to be loaded
 * @param {string} componentName - Name of the component (e.g., 'OrbitControls')
 * @returns {Promise} Promise that resolves when the component is available
 */
export function waitForThreeComponent(componentName) {
    return new Promise((resolve) => {
        // First wait for THREE to be loaded
        waitForThree().then((THREE) => {
            if (!THREE) {
                resolve(null);
                return;
            }
            
            // If component is already loaded, resolve immediately
            if (THREE[componentName]) {
                resolve(THREE[componentName]);
                return;
            }
            
            // Otherwise, check periodically
            const interval = setInterval(() => {
                if (THREE[componentName]) {
                    clearInterval(interval);
                    resolve(THREE[componentName]);
                }
            }, 100);
            
            // Set a timeout to prevent infinite waiting
            setTimeout(() => {
                clearInterval(interval);
                console.error(`Timeout waiting for THREE.${componentName} to load`);
                resolve(null);
            }, 10000);
        });
    });
}
```
现在我们需要解决Renderer.js中的问题，确保它能正确使用ThreeLoader：

```javascript:src/render/Renderer.js
/**
 * Renderer.js
 * Manages the WebGL renderer
 */

import { waitForThree, waitForThreeComponent } from '../utils/ThreeLoader.js';

export class RendererManager {
    /**
     * @param {SceneManager} sceneManager - The scene manager
     * @param {HTMLElement} container - Container element for the renderer
     */
    constructor(sceneManager, container) {
        // Store references
        this.sceneManager = sceneManager;
        this.container = container;
        
        // Initialize renderer when Three.js is loaded
        this.initRenderer();
    }
    
    /**
     * Initialize renderer after THREE is loaded
     */
    async initRenderer() {
        try {
            // Wait for THREE to be loaded
            const THREE = await waitForThree();
            if (!THREE) {
                console.error('Failed to load THREE');
                return;
            }
            
            console.log('THREE loaded successfully', THREE);
            
            // Create renderer
            this.renderer = new THREE.WebGLRenderer({ 
                antialias: true 
            });
            
            // Configure renderer
            this.renderer.setSize(window.innerWidth, window.innerHeight);
            this.renderer.setClearColor(0x111111); // Dark background
            
            // Add to container
            this.container.prepend(this.renderer.domElement);
            
            // Setup orbit controls
            await this.setupOrbitControls();
            
            // Handle window resize
            window.addEventListener('resize', this.handleResize.bind(this));
        } catch (error) {
            console.error('Error initializing renderer:', error);
        }
    }
    
    /**
     * Setup orbit controls after THREE.OrbitControls is loaded
     */
    async setupOrbitControls() {
        try {
            // Get THREE
            const THREE = await waitForThree();
            if (!THREE) {
                console.error('Failed to load THREE');
                return;
            }
            
            console.log('Setting up OrbitControls...');
            
            // Wait for the OrbitControls component to be ready
            await waitForThreeComponent('OrbitControls');
            
            // If OrbitControls still not available, show error
            if (!THREE.OrbitControls) {
                console.error('OrbitControls not available');
                return;
            }
            
            console.log('OrbitControls loaded successfully');
            
            // Create controls
            this.controls = new THREE.OrbitControls(
                this.sceneManager.getCamera(), 
                this.renderer.domElement
            );
            
            // Configure controls
            this.configureControls();
        } catch (error) {
            console.error('Error setting up OrbitControls:', error);
        }
    }
    
    /**
     * Configure orbit controls
     */
    configureControls() {
        if (!this.controls) return;
        
        this.controls.enableDamping = true;
        this.controls.dampingFactor = 0.05;
    }
    
    /**
     * Handle window resize
     */
    handleResize() {
        if (!this.renderer) return;
        
        // Update camera aspect ratio
        this.sceneManager.updateSize(window.innerWidth, window.innerHeight);
        
        // Update renderer size
        this.renderer.setSize(window.innerWidth, window.innerHeight);
    }
    
    /**
     * Enable or disable orbit controls
     * @param {boolean} enabled - Whether controls should be enabled
     */
    setControlsEnabled(enabled) {
        if (this.controls) {
            this.controls.enabled = enabled;
        }
    }
    
    /**
     * Render the scene
     */
    render() {
        if (!this.renderer) return;
        
        // Update controls if they exist
        if (this.controls && this.controls.enabled) {
            this.controls.update();
        }
        
        // Render scene
        this.renderer.render(
            this.sceneManager.getScene(), 
            this.sceneManager.getCamera()
        );
    }
    
    /**
     * Get the renderer
     * @returns {WebGLRenderer} The renderer
     */
    getRenderer() {
        return this.renderer;
    }
    
    /**
     * Get the controls
     * @returns {OrbitControls} The orbit controls
     */
    getControls() {
        return this.controls;
    }
    
    /**
     * Clean up resources
     */
    dispose() {
        if (this.controls) {
            this.controls.dispose();
        }
        if (this.renderer) {
            this.renderer.dispose();
        }
    }
}
```
现在我们需要修复Scene.js来使用全局THREE对象：

```javascript:src/render/Scene.js
/**
 * Scene.js
 * Manages the 3D scene setup and components
 */

import { waitForThree } from '../utils/ThreeLoader.js';

export class SceneManager {
    constructor() {
        // Initialize components once THREE is loaded
        this.init();
    }
    
    /**
     * Initialize scene components
     */
    async init() {
        try {
            // Wait for THREE to be loaded
            const THREE = await waitForThree();
            if (!THREE) {
                console.error('Failed to load THREE');
                return;
            }
            
            // Create scene
            this.scene = new THREE.Scene();
            
            // Create camera
            this.camera = new THREE.PerspectiveCamera(
                75,                                     // Field of view
                window.innerWidth / window.innerHeight, // Aspect ratio
                0.1,                                    // Near clipping plane
                1000                                    // Far clipping plane
            );
            
            // Set default camera position
            this.camera.position.set(100, 100, 200);
            this.camera.lookAt(0, 0, 0);
            
            // Setup lighting
            this._setupLighting(THREE);
            
            // Setup helper grid
            this._setupGrid(THREE);
            
            console.log('Scene initialized successfully');
        } catch (error) {
            console.error('Error initializing scene:', error);
        }
    }
    
    /**
     * Set up scene lighting
     * @param {Object} THREE - The Three.js object
     * @private
     */
    _setupLighting(THREE) {
        if (!this.scene) return;
        
        // Ambient light for overall scene illumination
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
        this.scene.add(ambientLight);
        
        // Main directional light (simulates sun)
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(0, 1, 1);
        this.scene.add(directionalLight);
        
        // Secondary directional light from another angle
        const directionalLight2 = new THREE.DirectionalLight(0xffffff, 0.5);
        directionalLight2.position.set(1, 0.5, -1);
        this.scene.add(directionalLight2);
    }
    
    /**
     * Set up grid helper
     * @param {Object} THREE - The Three.js object
     * @private
     */
    _setupGrid(THREE) {
        if (!this.scene) return;
        
        const gridHelper = new THREE.GridHelper(200, 50, 0x444444, 0x222222);
        this.scene.add(gridHelper);
        this.gridHelper = gridHelper;
    }
    
    /**
     * Update aspect ratio on window resize
     * @param {number} width - Window width
     * @param {number} height - Window height
     */
    updateSize(width, height) {
        if (!this.camera) return;
        
        this.camera.aspect = width / height;
        this.camera.updateProjectionMatrix();
    }
    
    /**
     * Add an object to the scene
     * @param {Object3D} object - The object to add
     */
    add(object) {
        if (!this.scene) return;
        this.scene.add(object);
    }
    
    /**
     * Remove an object from the scene
     * @param {Object3D} object - The object to remove
     */
    remove(object) {
        if (!this.scene) return;
        this.scene.remove(object);
    }
    
    /**
     * Get the scene
     * @returns {Scene} The scene
     */
    getScene() {
        return this.scene;
    }
    
    /**
     * Get the camera
     * @returns {PerspectiveCamera} The camera
     */
    getCamera() {
        return this.camera;
    }
    
    /**
     * Get the grid helper
     * @returns {GridHelper} The grid helper
     */
    getGridHelper() {
        return this.gridHelper;
    }
    
    /**
     * Update the scene - can be used for auto-rotation effects
     */
    update() {
        // Auto-rotation logic can be added here
    }
}
```
现在我们需要更新SpirographController和其他使用Three.js的组件：

```javascript:src/math/SpirographEquations.js
/**
 * SpirographEquations.js
 * Contains all mathematical formulas for calculating spirograph positions and derivatives
 */

import { waitForThree } from '../utils/ThreeLoader.js';

// Global cache for Vector3 constructor
let Vector3Constructor = null;

/**
 * Get Vector3 constructor
 * @returns {Promise<Function>} Vector3 constructor
 */
async function getVector3() {
    if (Vector3Constructor) {
        return Vector3Constructor;
    }
    
    const THREE = await waitForThree();
    if (!THREE) {
        console.error('Failed to load THREE');
        return null;
    }
    
    Vector3Constructor = THREE.Vector3;
    return Vector3Constructor;
}

/**
 * Create a new Vector3 instance
 * @param {number} x - X coordinate
 * @param {number} y - Y coordinate
 * @param {number} z - Z coordinate
 * @returns {Object} Vector3 instance
 */
function createVector3(x, y, z) {
    if (Vector3Constructor) {
        return new Vector3Constructor(x, y, z);
    }
    
    // Fallback if Vector3 is not available yet
    return { x, y, z, isTemporary: true };
}

/**
 * Calculate the position of a point on the spirograph
 * 
 * @param {number} t - Parameter value
 * @param {object} params - Spirograph parameters
 * @returns {Vector3} - 3D position
 */
export function getSpirographPosition(t, params) {
    const { outerRadius, innerRadius, penOffset, heightAmplitude } = params;
    
    // Basic spirograph equations for x and z
    const x = (outerRadius - innerRadius) * Math.cos(t) + penOffset * Math.cos((outerRadius - innerRadius) * t / innerRadius);
    const z = (outerRadius - innerRadius) * Math.sin(t) - penOffset * Math.sin((outerRadius - innerRadius) * t / innerRadius);
    
    // Add y-coordinate (height) based on a sine wave that varies with t
    // This creates a wave pattern in the vertical direction
    const y = heightAmplitude * Math.sin(3 * t) * Math.cos(2 * t);
    
    return createVector3(x, y, z);
}

/**
 * Calculate the derivative (tangent) at a point on the spirograph
 * 
 * @param {number} t - Parameter value
 * @param {object} params - Spirograph parameters
 * @returns {Vector3} - Normalized tangent vector
 */
export function getSpirographDerivative(t, params) {
    const { outerRadius, innerRadius, penOffset, heightAmplitude } = params;
    
    // Calculate derivatives in x, y, z directions
    const dxdt = -(outerRadius - innerRadius) * Math.sin(t) - 
                 penOffset * (outerRadius - innerRadius) / innerRadius * Math.sin((outerRadius - innerRadius) * t / innerRadius);
    
    const dzdt = (outerRadius - innerRadius) * Math.cos(t) - 
                penOffset * (outerRadius - innerRadius) / innerRadius * Math.cos((outerRadius - innerRadius) * t / innerRadius);
    
    const dydt = heightAmplitude * (3 * Math.cos(3 * t) * Math.cos(2 * t) - 2 * Math.sin(3 * t) * Math.sin(2 * t));
    
    // Create vector without normalization
    const vector = createVector3(dxdt, dydt, dzdt);
    
    // Normalize if it's a real Vector3
    if (Vector3Constructor && vector instanceof Vector3Constructor) {
        return vector.normalize();
    }
    
    // Simple normalization for fallback object
    const length = Math.sqrt(dxdt*dxdt + dydt*dydt + dzdt*dzdt);
    if (length > 0) {
        vector.x /= length;
        vector.y /= length;
        vector.z /= length;
    }
    
    return vector;
}

/**
 * Calculate the position of the inner gear
 * 
 * @param {number} t - Parameter value
 * @param {object} params - Spirograph parameters
 * @returns {Vector3} - 3D position of inner gear center
 */
export function getInnerGearPosition(t, params) {
    const { outerRadius, innerRadius, heightAmplitude } = params;
    
    const x = (outerRadius - innerRadius) * Math.cos(t);
    // Add some height variation to the gear as well, use reduced amplitude
    const y = heightAmplitude * 0.3 * Math.sin(3 * t);
    const z = (outerRadius - innerRadius) * Math.sin(t);
    
    return createVector3(x, y, z);
}

// Initialize Vector3 constructor
getVector3();
```

```javascript:src/spirograph/SpirographController.js
/**
 * SpirographController.js
 * Manages the generation and visualization of the spirograph
 */

import { getSpirographPosition, getSpirographDerivative, getInnerGearPosition } from '../math/SpirographEquations.js';
import { waitForThree, waitForThreeComponent } from '../utils/ThreeLoader.js';

export default class SpirographController {
    /**
     * @param {import('../render/Scene').default} scene - Three.js scene instance
     * @param {import('../render/Renderer').default} renderer - Three.js renderer instance
     */
    constructor(scene, renderer) {
        this.scene = scene;
        this.renderer = renderer;
        this.parameters = {
            outerRadius: 5,
            innerRadius: 3,
            penOffset: 2,
            heightAmplitude: 1.5,
            numPoints: 2000,
            curve: null,
            mesh: null,
            innerGear: null,
            outerGear: null,
            pen: null
        };

        this.objects = {
            curve: null,
            mesh: null,
            innerGear: null,
            outerGear: null,
            pen: null
        };

        this.animation = {
            t: 0,
            speed: 0.01,
            playing: false,
            animationId: null
        };
    }

    /**
     * Initialize the spirograph visualization
     */
    async init() {
        // Wait for THREE to be loaded
        const THREE = await waitForThree();
        if (!THREE) {
            console.error('THREE.js not loaded in SpirographController.init()');
            return;
        }

        // Create the spirograph
        await this.createSpirograph();
        
        // Set up animation
        this.startAnimation();
    }

    /**
     * Update spirograph parameters
     * @param {Object} newParams - New parameter values
     */
    async updateParameters(newParams) {
        // Update parameters
        Object.assign(this.parameters, newParams);
        
        // Regenerate the spirograph
        await this.createSpirograph();
    }

    /**
     * Create the spirograph visualization
     */
    async createSpirograph() {
        // Wait for THREE to be loaded
        const THREE = await waitForThree();
        if (!THREE) {
            console.error('THREE.js not loaded in SpirographController.createSpirograph()');
            return;
        }

        // Clean up existing objects
        this.cleanupObjects();

        // Generate points for the spirograph
        const { outerRadius, innerRadius, penOffset, heightAmplitude, numPoints } = this.parameters;
        const params = { outerRadius, innerRadius, penOffset, heightAmplitude };
        const points = [];

        for (let i = 0; i <= numPoints; i++) {
            const t = (i / numPoints) * Math.PI * 20; // Cover enough revolutions
            const point = getSpirographPosition(t, params);
            points.push(point);
        }

        // Create curve
        const curve = new THREE.CatmullRomCurve3(points);
        this.objects.curve = curve;

        // Create the curve's geometry
        await this.createCurveGeometry(curve);
        
        // Create gear visualizations
        await this.createGears();
        
        // Create the pen
        await this.createPen();
    }

    /**
     * Create the curve geometry and add it to the scene
     * @param {THREE.Curve} curve - The spirograph curve
     */
    async createCurveGeometry(curve) {
        // Wait for THREE components to be loaded
        const THREE = await waitForThree();
        if (!THREE) return;

        // Create tube geometry for the curve
        const tubeGeometry = new THREE.TubeGeometry(
            curve,
            this.parameters.numPoints / 5, // Number of segments
            0.1, // Tube radius
            8, // Radial segments
            false // Closed
        );

        // Create material with rainbow gradient
        const material = new THREE.MeshPhongMaterial({
            color: 0xffffff,
            emissive: 0x072534,
            side: THREE.DoubleSide,
            vertexColors: true
        });

        // Add vertex colors to create rainbow effect
        const colors = [];
        const numVertices = tubeGeometry.getAttribute('position').count;

        for (let i = 0; i < numVertices; i++) {
            // Create rainbow colors
            const hue = i / numVertices;
            const color = new THREE.Color().setHSL(hue, 1.0, 0.5);
            colors.push(color.r, color.g, color.b);
        }

        // Set vertex colors
        tubeGeometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));

        // Create mesh and add to scene
        const tubeMesh = new THREE.Mesh(tubeGeometry, material);
        this.objects.mesh = tubeMesh;
        this.scene.add(tubeMesh);
    }

    /**
     * Create gear visualizations
     */
    async createGears() {
        // Wait for THREE components to be loaded
        const THREE = await waitForThree();
        if (!THREE) return;

        // Create outer gear
        const outerGearGeometry = new THREE.RingGeometry(
            this.parameters.outerRadius - 0.2,
            this.parameters.outerRadius + 0.2,
            32
        );
        const outerGearMaterial = new THREE.MeshBasicMaterial({
            color: 0x4444ff,
            side: THREE.DoubleSide,
            transparent: true,
            opacity: 0.7
        });
        const outerGear = new THREE.Mesh(outerGearGeometry, outerGearMaterial);
        this.objects.outerGear = outerGear;
        this.scene.add(outerGear);

        // Create inner gear
        const innerGearGeometry = new THREE.CircleGeometry(this.parameters.innerRadius, 32);
        const innerGearMaterial = new THREE.MeshBasicMaterial({
            color: 0xff4444,
            side: THREE.DoubleSide,
            transparent: true,
            opacity: 0.7
        });
        const innerGear = new THREE.Mesh(innerGearGeometry, innerGearMaterial);
        this.objects.innerGear = innerGear;
        this.scene.add(innerGear);
    }

    /**
     * Create pen visualization
     */
    async createPen() {
        // Wait for THREE components to be loaded
        const THREE = await waitForThree();
        if (!THREE) return;

        // Create a small sphere to represent the pen
        const penGeometry = new THREE.SphereGeometry(0.2, 16, 16);
        const penMaterial = new THREE.MeshBasicMaterial({ color: 0x44ff44 });
        const pen = new THREE.Mesh(penGeometry, penMaterial);
        this.objects.pen = pen;
        this.scene.add(pen);
    }

    /**
     * Start the animation
     */
    startAnimation() {
        if (this.animation.playing) return;
        
        this.animation.playing = true;
        this.animate();
    }

    /**
     * Stop the animation
     */
    stopAnimation() {
        this.animation.playing = false;
        if (this.animation.animationId) {
            cancelAnimationFrame(this.animation.animationId);
            this.animation.animationId = null;
        }
    }

    /**
     * Animation loop
     */
    animate = async () => {
        if (!this.animation.playing) return;

        // Wait for THREE components to be loaded
        const THREE = await waitForThree();
        if (!THREE) return;

        // Update the position of the inner gear and pen
        this.updateGearAndPenPositions();
        
        // Render the scene
        this.renderer.render();
        
        // Increment t for the next frame
        this.animation.t += this.animation.speed;
        
        // Request next frame
        this.animation.animationId = requestAnimationFrame(this.animate);
    }

    /**
     * Update the position of the inner gear and pen
     */
    updateGearAndPenPositions() {
        if (!this.objects.innerGear || !this.objects.pen) return;

        const t = this.animation.t;
        const params = {
            outerRadius: this.parameters.outerRadius,
            innerRadius: this.parameters.innerRadius,
            penOffset: this.parameters.penOffset,
            heightAmplitude: this.parameters.heightAmplitude
        };

        // Update inner gear position
        const innerGearPos = getInnerGearPosition(t, params);
        this.objects.innerGear.position.set(innerGearPos.x, innerGearPos.y, innerGearPos.z);
        
        // Rotate the inner gear
        this.objects.innerGear.rotation.y = -t * (this.parameters.outerRadius / this.parameters.innerRadius);
        
        // Update pen position
        const penPos = getSpirographPosition(t, params);
        this.objects.pen.position.set(penPos.x, penPos.y, penPos.z);
    }

    /**
     * Clean up existing objects
     */
    cleanupObjects() {
        // Remove existing objects from the scene
        Object.values(this.objects).forEach(obj => {
            if (obj && typeof obj.geometry !== 'undefined') {
                this.scene.remove(obj);
                if (obj.geometry) obj.geometry.dispose();
                if (obj.material) {
                    if (Array.isArray(obj.material)) {
                        obj.material.forEach(mat => mat.dispose());
                    } else {
                        obj.material.dispose();
                    }
                }
            }
        });

        // Reset objects
        this.objects = {
            curve: null,
            mesh: null,
            innerGear: null,
            outerGear: null,
            pen: null
        };
    }

    /**
     * Dispose resources when controller is destroyed
     */
    dispose() {
        this.stopAnimation();
        this.cleanupObjects();
    }
}
```

```javascript:src/app.js
/**
 * Main application entry point
 */
import Scene from './render/Scene.js';
import Renderer from './render/Renderer.js';
import SpirographController from './spirograph/SpirographController.js';
import UIPanel from './ui/UIPanel.js';
import { waitForThree } from './utils/ThreeLoader.js';

class App {
    constructor() {
        this.scene = null;
        this.renderer = null;
        this.spirographController = null;
        this.uiPanel = null;
    }

    /**
     * Initialize the application
     */
    async init() {
        try {
            console.log('Initializing application...');
            
            // Ensure THREE is loaded
            const THREE = await waitForThree();
            if (!THREE) {
                console.error('Failed to load THREE.js');
                return;
            }
            console.log('THREE.js loaded successfully');
            
            // Initialize scene
            this.scene = new Scene();
            await this.scene.init();
            
            // Initialize renderer
            this.renderer = new Renderer(this.scene);
            await this.renderer.init();
            
            // Initialize spirograph controller
            this.spirographController = new SpirographController(this.scene, this.renderer);
            await this.spirographController.init();
            
            // Initialize UI panel
            this.uiPanel = new UIPanel(this.spirographController);
            this.uiPanel.init();
            
            console.log('Application initialized successfully');
        } catch (error) {
            console.error('Error initializing application:', error);
        }
    }

    /**
     * Clean up resources when application is destroyed
     */
    dispose() {
        if (this.spirographController) {
            this.spirographController.dispose();
        }
        
        if (this.renderer) {
            this.renderer.dispose();
        }
        
        if (this.scene) {
            this.scene.dispose();
        }
        
        if (this.uiPanel) {
            this.uiPanel.dispose();
        }
    }
}

// Create and initialize the application
const app = new App();
app.init();

// Export app instance for debugging
window.app = app;
```

```javascript:src/ui/UIPanel.js
/**
 * UIPanel.js
 * Creates and manages the UI control panel for the spirograph
 */

export default class UIPanel {
    /**
     * @param {import('../spirograph/SpirographController').default} spirographController - Spirograph controller instance
     */
    constructor(spirographController) {
        this.spirographController = spirographController;
        this.container = null;
    }

    /**
     * Initialize the UI panel
     */
    init() {
        this.createPanel();
        this.setupEventListeners();
    }

    /**
     * Create the UI panel
     */
    createPanel() {
        // Create container
        this.container = document.createElement('div');
        this.container.className = 'ui-panel';
        this.container.innerHTML = `
            <div class="ui-header">
                <h2>Spirograph Controls</h2>
            </div>
            <div class="ui-content">
                <div class="control-group">
                    <label for="outerRadius">Outer Radius:</label>
                    <input type="range" id="outerRadius" min="3" max="10" step="0.1" value="5">
                    <span class="value-display">5</span>
                </div>
                <div class="control-group">
                    <label for="innerRadius">Inner Radius:</label>
                    <input type="range" id="innerRadius" min="1" max="5" step="0.1" value="3">
                    <span class="value-display">3</span>
                </div>
                <div class="control-group">
                    <label for="penOffset">Pen Offset:</label>
                    <input type="range" id="penOffset" min="0.5" max="4" step="0.1" value="2">
                    <span class="value-display">2</span>
                </div>
                <div class="control-group">
                    <label for="heightAmplitude">Height Amplitude:</label>
                    <input type="range" id="heightAmplitude" min="0" max="3" step="0.1" value="1.5">
                    <span class="value-display">1.5</span>
                </div>
                <div class="control-group">
                    <label for="speed">Animation Speed:</label>
                    <input type="range" id="speed" min="0.001" max="0.05" step="0.001" value="0.01">
                    <span class="value-display">0.01</span>
                </div>
                <div class="control-group">
                    <button id="reset-btn">Reset</button>
                    <button id="toggle-animation-btn">Pause</button>
                </div>
            </div>
        `;

        // Add styles
        const style = document.createElement('style');
        style.textContent = `
            .ui-panel {
                position: absolute;
                top: 20px;
                right: 20px;
                width: 300px;
                background-color: rgba(30, 30, 30, 0.8);
                color: white;
                border-radius: 8px;
                overflow: hidden;
                box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
                font-family: Arial, sans-serif;
                z-index: 1000;
            }
            
            .ui-header {
                background-color: rgba(50, 50, 50, 0.9);
                padding: 12px 15px;
                border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            }
            
            .ui-header h2 {
                margin: 0;
                font-size: 18px;
            }
            
            .ui-content {
                padding: 15px;
            }
            
            .control-group {
                margin-bottom: 15px;
                display: flex;
                flex-wrap: wrap;
                align-items: center;
            }
            
            .control-group label {
                display: block;
                width: 100%;
                margin-bottom: 5px;
                font-size: 14px;
            }
            
            .control-group input[type="range"] {
                width: 85%;
                margin-right: 10px;
            }
            
            .value-display {
                width: 10%;
                text-align: right;
                font-size: 14px;
            }
            
            button {
                background-color: #3498db;
                color: white;
                border: none;
                padding: 8px 15px;
                border-radius: 4px;
                cursor: pointer;
                font-size: 14px;
                margin-right: 10px;
                transition: background-color 0.3s;
            }
            
            button:hover {
                background-color: #2980b9;
            }
        `;

        // Add to document
        document.head.appendChild(style);
        document.body.appendChild(this.container);
    }

    /**
     * Set up event listeners for UI controls
     */
    setupEventListeners() {
        // Get all slider inputs
        const sliders = this.container.querySelectorAll('input[type="range"]');
        
        // Add event listeners to each slider
        sliders.forEach(slider => {
            // Update value display when slider changes
            const updateDisplay = () => {
                const display = slider.nextElementSibling;
                display.textContent = parseFloat(slider.value).toFixed(2);
                
                // Update spirograph parameters
                this.updateSpirographParameters();
            };
            
            slider.addEventListener('input', updateDisplay);
            slider.addEventListener('change', updateDisplay);
            
            // Initialize value display
            updateDisplay();
        });
        
        // Reset button
        const resetBtn = this.container.querySelector('#reset-btn');
        resetBtn.addEventListener('click', () => {
            // Reset all sliders to default values
            this.container.querySelector('#outerRadius').value = '5';
            this.container.querySelector('#innerRadius').value = '3';
            this.container.querySelector('#penOffset').value = '2';
            this.container.querySelector('#heightAmplitude').value = '1.5';
            this.container.querySelector('#speed').value = '0.01';
            
            // Update displays
            sliders.forEach(slider => {
                const display = slider.nextElementSibling;
                display.textContent = parseFloat(slider.value).toFixed(2);
            });
            
            // Update spirograph
            this.updateSpirographParameters();
        });
        
        // Toggle animation button
        const toggleAnimationBtn = this.container.querySelector('#toggle-animation-btn');
        toggleAnimationBtn.addEventListener('click', () => {
            const isPlaying = this.spirographController.animation.playing;
            
            if (isPlaying) {
                this.spirographController.stopAnimation();
                toggleAnimationBtn.textContent = 'Resume';
            } else {
                this.spirographController.startAnimation();
                toggleAnimationBtn.textContent = 'Pause';
            }
        });
    }

    /**
     * Update spirograph parameters based on UI values
     */
    updateSpirographParameters() {
        // Get values from UI
        const outerRadius = parseFloat(this.container.querySelector('#outerRadius').value);
        const innerRadius = parseFloat(this.container.querySelector('#innerRadius').value);
        const penOffset = parseFloat(this.container.querySelector('#penOffset').value);
        const heightAmplitude = parseFloat(this.container.querySelector('#heightAmplitude').value);
        const speed = parseFloat(this.container.querySelector('#speed').value);
        
        // Update animation speed directly
        this.spirographController.animation.speed = speed;
        
        // Update other parameters
        this.spirographController.updateParameters({
            outerRadius,
            innerRadius,
            penOffset,
            heightAmplitude
        });
    }

    /**
     * Clean up resources when UI panel is destroyed
     */
    dispose() {
        // Remove the UI container from the document
        if (this.container && this.container.parentNode) {
            this.container.parentNode.removeChild(this.container);
        }
    }
}
```

```html:index.html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Spirograph</title>
    <link rel="stylesheet" href="spirograph.css">
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
        }
        canvas {
            display: block;
        }
    </style>
</head>
<body>
    <div id="app-container"></div>
    
    <!-- Load Three.js from CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    
    <!-- Load application -->
    <script type="module" src="src/app.js"></script>
</body>
</html>
```

```bash
node server.js
```

```css:spirograph.css
/* 
 * Spirograph CSS
 * Main styles for the 3D Spirograph application
 */

body {
    margin: 0;
    overflow: hidden;
    background-color: #000;
    font-family: Arial, sans-serif;
    color: #fff;
}

canvas {
    display: block;
    width: 100%;
    height: 100%;
}

/* UI Panel styles are now defined in UIPanel.js */

/* Loading screen */
.loading-screen {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: #000;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    z-index: 2000;
    transition: opacity 0.5s ease-in-out;
}

.loading-screen.hidden {
    opacity: 0;
    pointer-events: none;
}

.loading-screen h1 {
    color: #fff;
    font-size: 24px;
    margin-bottom: 20px;
}

.loading-bar-container {
    width: 300px;
    height: 10px;
    background-color: rgba(255, 255, 255, 0.1);
    border-radius: 5px;
    overflow: hidden;
}

.loading-bar {
    height: 100%;
    width: 0%;
    background: linear-gradient(90deg, #3498db, #2ecc71);
    transition: width 0.3s ease-in-out;
    border-radius: 5px;
}

/* GitHub link */
.github-link {
    position: absolute;
    bottom: 20px;
    right: 20px;
    color: #fff;
    text-decoration: none;
    display: flex;
    align-items: center;
    opacity: 0.6;
    transition: opacity 0.3s ease;
    z-index: 1000;
}

.github-link:hover {
    opacity: 1;
}

.github-icon {
    width: 20px;
    height: 20px;
    margin-right: 5px;
}

/* Responsive adjustments */
@media (max-width: 768px) {
    .ui-panel {
        width: 250px;
    }
    
    .loading-bar-container {
        width: 250px;
    }
}
```

```bash
ls -la src
```

```bash
curl http://localhost:3000/
```

```html:index.html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Spirograph</title>
    <link rel="stylesheet" href="spirograph.css">
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
        }
        canvas {
            display: block;
        }
    </style>
</head>
<body>
    <div id="app-container"></div>
    
    <!-- GitHub repository link -->
    <a href="https://github.com/jankeesvw/3d-spirograph" class="github-link" target="_blank">
        <svg class="github-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="white">
            <path d="M12 0c-6.626 0-12 5.373-12 12 0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576 4.765-1.589 8.199-6.086 8.199-11.386 0-6.627-5.373-12-12-12z"/>
        </svg>
        GitHub
    </a>
    
    <!-- Load Three.js from CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    
    <!-- Load application -->
    <script type="module" src="src/app.js"></script>
</body>
</html>
```

```bash
curl http://localhost:3000/src/app.js
```
我们已经完成了主要的重构工作，将原始的单文件应用程序转换为模块化的结构。以下是当前的实现状态：

1. **模块化结构**：我们创建了一个清晰的模块化结构，包括：
   - 渲染模块 (`render/`)
   - 数学计算模块 (`math/`)
   - UI控制模块 (`ui/`)
   - Spirograph核心控制器 (`spirograph/`)
   - 工具类 (`utils/`)

2. **核心功能**：
   - 修改了THREE.js的加载方式，现在使用全局变量而不是ES模块导入
   - 创建了`ThreeLoader`工具类来确保THREE.js加载完成
   - 重写了`SpirographController`，提供核心的旋轮绘图功能
   - 实现了UI面板来控制各种参数

3. **应用程序入口**：
   - 创建了`app.js`作为应用程序的主入口点
   - 初始化各个组件并连接它们

4. **HTML/CSS**：
   - 更新了`index.html`和`spirograph.css`以适应新的模块化结构

应用程序现在应该能够运行，但可能还有一些小问题需要解决。使用浏览器访问http://localhost:3000并查看控制台可能会帮助识别任何剩余的问题。对于任何显示的错误，我们可以逐一解决。
