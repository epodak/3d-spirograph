---
marp: true
theme: am_blue
paginate: true
math: katex
headingDivider: [2,3,4,5]
backgroundColor: #D0E8D6DA
---

I'll create the directory structure and convert some key components to get started with the modular architecture.

```bash
mkdir -p src/core src/math src/render src/ui src/spirograph src/effects src/camera src/gears src/presets src/utils
```
Now let's start creating some of the key components, beginning with the mathematical core and engine setup.

```javascript:src/math/SpirographEquations.js
/**
 * SpirographEquations.js
 * Contains all mathematical formulas for calculating spirograph positions and derivatives
 */

import { Vector3 } from 'three';

/**
 * Calculate the position of a point on the spirograph
 * 
 * @param {number} t - Parameter value
 * @param {object} params - Spirograph parameters
 * @returns {Vector3} - 3D position
 */
export function getSpirographPosition(t, params) {
    const { outerRadius, innerRadius, penOffset, heightAmplitude } = params;
    
    // Basic spirograph equations for x and z
    const x = (outerRadius - innerRadius) * Math.cos(t) + penOffset * Math.cos((outerRadius - innerRadius) * t / innerRadius);
    const z = (outerRadius - innerRadius) * Math.sin(t) - penOffset * Math.sin((outerRadius - innerRadius) * t / innerRadius);
    
    // Add y-coordinate (height) based on a sine wave that varies with t
    // This creates a wave pattern in the vertical direction
    const y = heightAmplitude * Math.sin(3 * t) * Math.cos(2 * t);
    
    return new Vector3(x, y, z);
}

/**
 * Calculate the derivative (tangent) at a point on the spirograph
 * 
 * @param {number} t - Parameter value
 * @param {object} params - Spirograph parameters
 * @returns {Vector3} - Normalized tangent vector
 */
export function getSpirographDerivative(t, params) {
    const { outerRadius, innerRadius, penOffset, heightAmplitude } = params;
    
    // Calculate derivatives in x, y, z directions
    const dxdt = -(outerRadius - innerRadius) * Math.sin(t) - 
                 penOffset * (outerRadius - innerRadius) / innerRadius * Math.sin((outerRadius - innerRadius) * t / innerRadius);
    
    const dzdt = (outerRadius - innerRadius) * Math.cos(t) - 
                penOffset * (outerRadius - innerRadius) / innerRadius * Math.cos((outerRadius - innerRadius) * t / innerRadius);
    
    const dydt = heightAmplitude * (3 * Math.cos(3 * t) * Math.cos(2 * t) - 2 * Math.sin(3 * t) * Math.sin(2 * t));
    
    // Return normalized derivative vector (unit tangent vector)
    return new Vector3(dxdt, dydt, dzdt).normalize();
}

/**
 * Calculate the position of the inner gear
 * 
 * @param {number} t - Parameter value
 * @param {object} params - Spirograph parameters
 * @returns {Vector3} - 3D position of inner gear center
 */
export function getInnerGearPosition(t, params) {
    const { outerRadius, innerRadius, heightAmplitude } = params;
    
    const x = (outerRadius - innerRadius) * Math.cos(t);
    // Add some height variation to the gear as well, use reduced amplitude
    const y = heightAmplitude * 0.3 * Math.sin(3 * t);
    const z = (outerRadius - innerRadius) * Math.sin(t);
    
    return new Vector3(x, y, z);
}
```
Now, let's create the spirograph model to handle the parameters:

```javascript:src/spirograph/SpirographModel.js
/**
 * SpirographModel.js
 * Data model for spirograph parameters and state
 */

export class SpirographModel {
    constructor() {
        // Default parameters
        this.params = {
            // Geometric parameters
            outerRadius: 80,
            innerRadius: 40,
            penOffset: 60,
            heightAmplitude: 30,
            
            // Animation parameters
            speed: 1,
            lineThickness: 3,
            primaryColor: '#ff0066',
            secondaryColor: '#00ffcc',
            showGears: false,
            rollercoasterView: false,
            
            // Animation state
            t: 0,               // Current parameter t (for point calculation)
            cameraT: 0,         // Camera position parameter
            isDrawing: true,    // Whether currently drawing
            drawSpeed: 1,       // Points to add per frame
            maxPoints: 10000,   // Maximum number of points
            
            // Camera parameters
            cameraHeight: 10,
            cameraDistance: 0,
            cameraTilt: 0.2,
            autoRotate: true
        };
        
        // Points array for the spirograph curve
        this.points = [];
    }
    
    /**
     * Update parameters from UI inputs
     * @param {Object} newParams - New parameter values
     */
    updateParams(newParams) {
        // Update only the provided parameters
        Object.assign(this.params, newParams);
        
        // Update derived parameters
        this.updateDerivedParams();
    }
    
    /**
     * Update parameters that depend on other parameters
     */
    updateDerivedParams() {
        // Ensure drawSpeed is at least 1
        this.params.drawSpeed = Math.max(1, Math.floor(this.params.speed * 3));
    }
    
    /**
     * Reset the spirograph to initial state
     */
    reset() {
        this.points = [];
        this.params.t = 0;
        this.params.cameraT = 0;
        this.params.isDrawing = true;
    }
    
    /**
     * Adds a new point to the spirograph
     * @param {Vector3} point - Point to add
     */
    addPoint(point) {
        this.points.push(point);
        
        // Stop drawing if maximum points reached
        if (this.points.length >= this.params.maxPoints) {
            this.params.isDrawing = false;
        }
    }
    
    /**
     * Advance the parameter t
     */
    advanceT() {
        this.params.t += 0.01 * this.params.speed;
    }
    
    /**
     * Get all points
     * @returns {Array} Array of points
     */
    getPoints() {
        return this.points;
    }
    
    /**
     * Get current parameters
     * @returns {Object} Current parameters
     */
    getParams() {
        return this.params;
    }
}
```
Now let's create the geometry manager for the spirograph:

```javascript:src/spirograph/SpirographGeometry.js
/**
 * SpirographGeometry.js
 * Manages the creation and update of the spirograph's geometry
 */

import { 
    BufferGeometry, 
    Line,
    Points,
    LineBasicMaterial,
    PointsMaterial
} from 'three';

export class SpirographGeometry {
    /**
     * @param {SpirographModel} model - The data model
     */
    constructor(model) {
        this.model = model;
        
        // Create materials
        this.lineMaterial = new LineBasicMaterial({ 
            color: model.getParams().primaryColor,
            transparent: true,
            opacity: 0.9
        });
        
        this.particleMaterial = new PointsMaterial({
            color: model.getParams().secondaryColor, 
            size: model.getParams().lineThickness * 0.5,
            transparent: true,
            opacity: 0.8
        });
        
        // Create geometries
        this.lineGeometry = new BufferGeometry();
        this.particlesGeometry = new BufferGeometry();
        
        // Create meshes
        this.line = new Line(this.lineGeometry, this.lineMaterial);
        this.particles = new Points(this.particlesGeometry, this.particleMaterial);
    }
    
    /**
     * Update the geometry with current points
     */
    updateGeometry() {
        // Get points from the model
        const points = this.model.getPoints();
        
        // Clean up old geometries
        if (this.lineGeometry) this.lineGeometry.dispose();
        if (this.particlesGeometry) this.particlesGeometry.dispose();
        
        // Create new geometries
        this.lineGeometry = new BufferGeometry().setFromPoints(points);
        this.particlesGeometry = new BufferGeometry().setFromPoints(points);
        
        // Update meshes with new geometries
        this.line.geometry = this.lineGeometry;
        this.particles.geometry = this.particlesGeometry;
    }
    
    /**
     * Update materials based on current parameters
     */
    updateMaterials() {
        const params = this.model.getParams();
        
        // Update colors
        this.lineMaterial.color.set(params.primaryColor);
        this.particleMaterial.color.set(params.secondaryColor);
        
        // Update particle size based on line thickness
        this.particleMaterial.size = params.lineThickness * 0.5;
        this.particleMaterial.needsUpdate = true;
    }
    
    /**
     * Get the line mesh
     * @returns {Line} Line mesh
     */
    getLine() {
        return this.line;
    }
    
    /**
     * Get the particles mesh
     * @returns {Points} Particles mesh
     */
    getParticles() {
        return this.particles;
    }
    
    /**
     * Clean up resources
     */
    dispose() {
        this.lineGeometry.dispose();
        this.particlesGeometry.dispose();
        this.lineMaterial.dispose();
        this.particleMaterial.dispose();
    }
}
```
Let's create the controller for the spirograph which will coordinate between the model and geometry:

```javascript:src/spirograph/SpirographController.js
/**
 * SpirographController.js
 * Main controller for spirograph generation and lifecycle
 */

import { Group } from 'three';
import { SpirographModel } from './SpirographModel.js';
import { SpirographGeometry } from './SpirographGeometry.js';
import { getSpirographPosition } from '../math/SpirographEquations.js';

export class SpirographController {
    /**
     * @param {Object} scene - The Three.js scene
     */
    constructor(scene) {
        // Create data model
        this.model = new SpirographModel();
        
        // Create geometry manager
        this.geometry = new SpirographGeometry(this.model);
        
        // Create a group to hold all spirograph elements
        this.group = new Group();
        this.group.add(this.geometry.getLine());
        this.group.add(this.geometry.getParticles());
        
        // Add to scene
        scene.add(this.group);
    }
    
    /**
     * Update the spirograph state
     * @returns {boolean} Whether new points were added
     */
    update() {
        const params = this.model.getParams();
        
        // If not drawing, return false
        if (!params.isDrawing) {
            return false;
        }
        
        let pointsAdded = false;
        
        // Add points based on draw speed
        for (let i = 0; i < params.drawSpeed; i++) {
            // Advance the parameter t
            this.model.advanceT();
            
            // Calculate and add new point
            const point = getSpirographPosition(params.t, params);
            this.model.addPoint(point);
            
            pointsAdded = true;
            
            // Stop if we've reached maximum points
            if (!params.isDrawing) {
                break;
            }
        }
        
        // Update geometry if points were added
        if (pointsAdded) {
            this.geometry.updateGeometry();
        }
        
        return pointsAdded;
    }
    
    /**
     * Update parameters from UI
     * @param {Object} newParams - New parameter values
     */
    updateParams(newParams) {
        this.model.updateParams(newParams);
        this.geometry.updateMaterials();
    }
    
    /**
     * Reset the spirograph
     */
    reset() {
        this.model.reset();
        this.geometry.updateGeometry();
    }
    
    /**
     * Clear the spirograph points
     */
    clear() {
        this.model.reset();
        this.geometry.updateGeometry();
    }
    
    /**
     * Get the current parameters
     * @returns {Object} Current parameters
     */
    getParams() {
        return this.model.getParams();
    }
    
    /**
     * Get the spirograph group
     * @returns {Group} Spirograph group
     */
    getGroup() {
        return this.group;
    }
    
    /**
     * Clean up resources
     */
    dispose() {
        this.geometry.dispose();
    }
}
```
Now let's create the core engine and scene setup:

```javascript:src/render/Scene.js
/**
 * Scene.js
 * Manages the 3D scene setup and components
 */

import { 
    Scene,
    PerspectiveCamera,
    AmbientLight,
    DirectionalLight,
    GridHelper
} from 'three';

export class SceneManager {
    constructor() {
        // Create scene
        this.scene = new Scene();
        
        // Create camera
        this.camera = new PerspectiveCamera(
            75,                                     // Field of view
            window.innerWidth / window.innerHeight, // Aspect ratio
            0.1,                                    // Near clipping plane
            1000                                    // Far clipping plane
        );
        
        // Set default camera position
        this.camera.position.set(100, 100, 200);
        this.camera.lookAt(0, 0, 0);
        
        // Setup lighting
        this._setupLighting();
        
        // Setup helper grid
        this._setupGrid();
    }
    
    /**
     * Set up scene lighting
     * @private
     */
    _setupLighting() {
        // Ambient light for overall scene illumination
        const ambientLight = new AmbientLight(0xffffff, 0.5);
        this.scene.add(ambientLight);
        
        // Main directional light (simulates sun)
        const directionalLight = new DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(0, 1, 1);
        this.scene.add(directionalLight);
        
        // Secondary directional light from another angle
        const directionalLight2 = new DirectionalLight(0xffffff, 0.5);
        directionalLight2.position.set(1, 0.5, -1);
        this.scene.add(directionalLight2);
    }
    
    /**
     * Set up grid helper
     * @private
     */
    _setupGrid() {
        const gridHelper = new GridHelper(200, 50, 0x444444, 0x222222);
        this.scene.add(gridHelper);
        this.gridHelper = gridHelper;
    }
    
    /**
     * Update aspect ratio on window resize
     * @param {number} width - Window width
     * @param {number} height - Window height
     */
    updateSize(width, height) {
        this.camera.aspect = width / height;
        this.camera.updateProjectionMatrix();
    }
    
    /**
     * Add an object to the scene
     * @param {Object3D} object - The object to add
     */
    add(object) {
        this.scene.add(object);
    }
    
    /**
     * Remove an object from the scene
     * @param {Object3D} object - The object to remove
     */
    remove(object) {
        this.scene.remove(object);
    }
    
    /**
     * Get the scene
     * @returns {Scene} The scene
     */
    getScene() {
        return this.scene;
    }
    
    /**
     * Get the camera
     * @returns {PerspectiveCamera} The camera
     */
    getCamera() {
        return this.camera;
    }
    
    /**
     * Get the grid helper
     * @returns {GridHelper} The grid helper
     */
    getGridHelper() {
        return this.gridHelper;
    }
    
    /**
     * Update the scene - can be used for auto-rotation effects
     */
    update() {
        // Auto-rotation logic can be added here
    }
}
```
Let's create the renderer:

```javascript:src/render/Renderer.js
/**
 * Renderer.js
 * Manages the WebGL renderer
 */

import { WebGLRenderer } from 'three';
import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js';

export class RendererManager {
    /**
     * @param {SceneManager} sceneManager - The scene manager
     * @param {HTMLElement} container - Container element for the renderer
     */
    constructor(sceneManager, container) {
        // Store references
        this.sceneManager = sceneManager;
        this.container = container;
        
        // Create renderer
        this.renderer = new WebGLRenderer({ 
            antialias: true 
        });
        
        // Configure renderer
        this.renderer.setSize(window.innerWidth, window.innerHeight);
        this.renderer.setClearColor(0x111111); // Dark background
        
        // Add to container
        this.container.prepend(this.renderer.domElement);
        
        // Setup orbit controls
        this.controls = new OrbitControls(
            this.sceneManager.getCamera(), 
            this.renderer.domElement
        );
        
        this.configureControls();
        
        // Handle window resize
        window.addEventListener('resize', this.handleResize.bind(this));
    }
    
    /**
     * Configure orbit controls
     */
    configureControls() {
        this.controls.enableDamping = true;
        this.controls.dampingFactor = 0.05;
    }
    
    /**
     * Handle window resize
     */
    handleResize() {
        // Update camera aspect ratio
        this.sceneManager.updateSize(window.innerWidth, window.innerHeight);
        
        // Update renderer size
        this.renderer.setSize(window.innerWidth, window.innerHeight);
    }
    
    /**
     * Enable or disable orbit controls
     * @param {boolean} enabled - Whether controls should be enabled
     */
    setControlsEnabled(enabled) {
        this.controls.enabled = enabled;
    }
    
    /**
     * Render the scene
     */
    render() {
        // Update controls
        if (this.controls.enabled) {
            this.controls.update();
        }
        
        // Render scene
        this.renderer.render(
            this.sceneManager.getScene(), 
            this.sceneManager.getCamera()
        );
    }
    
    /**
     * Get the renderer
     * @returns {WebGLRenderer} The renderer
     */
    getRenderer() {
        return this.renderer;
    }
    
    /**
     * Get the controls
     * @returns {OrbitControls} The orbit controls
     */
    getControls() {
        return this.controls;
    }
    
    /**
     * Clean up resources
     */
    dispose() {
        this.controls.dispose();
        this.renderer.dispose();
    }
}
```
Let's implement the camera system now:

```javascript:src/camera/CameraController.js
/**
 * CameraController.js
 * Manages camera functionality including the rollercoaster mode
 */

import { Vector3 } from 'three';
import { getSpirographPosition, getSpirographDerivative } from '../math/SpirographEquations.js';

export class CameraController {
    /**
     * @param {SceneManager} sceneManager - The scene manager
     * @param {RendererManager} rendererManager - The renderer manager
     */
    constructor(sceneManager, rendererManager) {
        this.sceneManager = sceneManager;
        this.rendererManager = rendererManager;
        
        // Get camera reference
        this.camera = sceneManager.getCamera();
        
        // Default camera parameters
        this.params = {
            rollercoasterView: false,
            cameraHeight: 10,
            cameraDistance: 0,
            cameraTilt: 0.2,
            cameraT: 0,
            t: 0
        };
    }
    
    /**
     * Update camera parameters
     * @param {Object} newParams - New camera parameters
     */
    updateParams(newParams) {
        Object.assign(this.params, newParams);
        
        // If in rollercoaster view, update position immediately
        if (this.params.rollercoasterView) {
            this.setCameraToSpirographPosition(this.params.cameraT);
        }
    }
    
    /**
     * Toggle rollercoaster view
     * @param {boolean} enabled - Whether rollercoaster view is enabled
     * @param {Object} spirographParams - Spirograph parameters
     */
    setRollercoasterView(enabled, spirographParams) {
        this.params.rollercoasterView = enabled;
        
        // Update current t value from spirograph
        if (spirographParams) {
            this.params.t = spirographParams.t;
        }
        
        // Enable/disable orbit controls
        this.rendererManager.setControlsEnabled(!enabled);
        
        if (enabled) {
            // Set camera to current position on the spirograph
            this.params.cameraT = this.params.t;
            this.setCameraToSpirographPosition(this.params.cameraT);
        } else {
            // Reset to default camera position
            this.resetCameraPosition();
        }
    }
    
    /**
     * Reset camera to default position
     */
    resetCameraPosition() {
        this.camera.position.set(100, 100, 200);
        this.camera.lookAt(0, 0, 0);
        this.camera.up.set(0, 1, 0);
    }
    
    /**
     * Reset camera parameters
     */
    resetCameraParams() {
        this.params.cameraHeight = 10;
        this.params.cameraDistance = 0;
        this.params.cameraTilt = 0.2;
    }
    
    /**
     * Set camera position to a specific point on the spirograph
     * @param {number} t - Parameter value
     */
    setCameraToSpirographPosition(t) {
        // Get spirograph position and tangent at t
        const spirographParams = {
            outerRadius: this.params.outerRadius,
            innerRadius: this.params.innerRadius,
            penOffset: this.params.penOffset,
            heightAmplitude: this.params.heightAmplitude
        };
        
        const pos = getSpirographPosition(t, spirographParams);
        const tangent = getSpirographDerivative(t, spirographParams);
        
        // Calculate up vector perpendicular to tangent
        const worldUp = new Vector3(0, 1, 0);
        const right = new Vector3().crossVectors(tangent, worldUp).normalize();
        const up = new Vector3().crossVectors(right, tangent).normalize();
        
        // Apply height offset
        const heightOffset = new Vector3().copy(up).multiplyScalar(this.params.cameraHeight);
        
        // Apply distance offset along tangent
        const distanceOffset = new Vector3().copy(tangent).multiplyScalar(this.params.cameraDistance);
        
        // Calculate final camera position
        const finalPos = new Vector3().copy(pos).add(heightOffset).add(distanceOffset);
        this.camera.position.copy(finalPos);
        
        // Calculate look-at point (ahead of current position)
        const targetPos = new Vector3().copy(pos).add(tangent.clone().multiplyScalar(5));
        this.camera.lookAt(targetPos);
        
        // Apply camera tilt
        if (this.params.cameraTilt > 0) {
            const center = new Vector3(0, 0, 0);
            const toCenterDir = new Vector3().subVectors(center, pos).normalize();
            const tiltVector = new Vector3().crossVectors(tangent, toCenterDir).normalize();
            this.camera.up.copy(up).lerp(tiltVector, this.params.cameraTilt);
        } else {
            this.camera.up.copy(up);
        }
    }
    
    /**
     * Update camera position for rollercoaster view
     * @param {number} t - Current t value from spirograph
     */
    update(t) {
        if (this.params.rollercoasterView) {
            // Update camera position to match current spirograph point
            this.params.cameraT = t;
            this.setCameraToSpirographPosition(this.params.cameraT);
        }
    }
    
    /**
     * Get camera parameters
     * @returns {Object} Camera parameters
     */
    getParams() {
        return this.params;
    }
}
```
Now let's implement the gear visualization system:

```javascript:src/gears/GearSystem.js
/**
 * GearSystem.js
 * Manages the visualization of gears in the spirograph
 */

import { 
    Group, 
    Mesh, 
    RingGeometry, 
    MeshBasicMaterial,
    SphereGeometry,
    Line,
    BufferGeometry,
    LineBasicMaterial,
    Vector3
} from 'three';

import { getInnerGearPosition, getSpirographPosition } from '../math/SpirographEquations.js';

export class GearSystem {
    /**
     * @param {SceneManager} sceneManager - The scene manager
     */
    constructor(sceneManager) {
        this.sceneManager = sceneManager;
        
        // Parameters
        this.params = {
            outerRadius: 80,
            innerRadius: 40,
            penOffset: 60,
            heightAmplitude: 30,
            primaryColor: '#ff0066',
            showGears: false
        };
        
        // Create a group to hold all gear elements
        this.group = new Group();
        
        // Add to scene
        sceneManager.add(this.group);
        
        // Create gear elements
        this._createGearElements();
        
        // Initially update visibility
        this.updateVisibility();
    }
    
    /**
     * Create all gear visualization elements
     * @private
     */
    _createGearElements() {
        // Outer gear (fixed)
        const outerGearGeometry = new RingGeometry(79, 80, 64);
        const outerGearMaterial = new MeshBasicMaterial({ 
            color: 0x66bbff,
            transparent: true,
            opacity: 0.7,
            side: 2 // DoubleSide
        });
        this.outerGear = new Mesh(outerGearGeometry, outerGearMaterial);
        this.outerGear.rotation.x = Math.PI / 2; // Rotate to lie in XZ plane
        this.outerGear.position.y = 40;
        
        // Inner gear (moving)
        const innerGearGeometry = new RingGeometry(39, 40, 64);
        const innerGearMaterial = new MeshBasicMaterial({ 
            color: 0xffdd44,
            transparent: true,
            opacity: 0.7,
            side: 2 // DoubleSide
        });
        this.innerGear = new Mesh(innerGearGeometry, innerGearMaterial);
        this.innerGear.rotation.x = Math.PI / 2; // Rotate to lie in XZ plane
        
        // Pen (drawing point)
        const penGeometry = new SphereGeometry(3, 16, 16);
        this.penMaterial = new MeshBasicMaterial({ color: 0xff3377 });
        this.pen = new Mesh(penGeometry, this.penMaterial);
        
        // Pen arm (connecting inner gear to pen)
        const penArmGeometry = new BufferGeometry();
        this.penArmMaterial = new LineBasicMaterial({ 
            color: 0xff3377,
            transparent: true,
            opacity: 0.9
        });
        this.penArm = new Line(penArmGeometry, this.penArmMaterial);
        
        // Add all elements to the group
        this.group.add(this.outerGear);
        this.group.add(this.innerGear);
        this.group.add(this.pen);
        this.group.add(this.penArm);
    }
    
    /**
     * Update gear geometry based on current parameters
     */
    updateGeometry() {
        // Update outer gear geometry
        if (this.outerGear.geometry) {
            this.outerGear.geometry.dispose();
        }
        this.outerGear.geometry = new RingGeometry(
            this.params.outerRadius - 1, 
            this.params.outerRadius, 
            64
        );
        
        // Update inner gear geometry
        if (this.innerGear.geometry) {
            this.innerGear.geometry.dispose();
        }
        this.innerGear.geometry = new RingGeometry(
            this.params.innerRadius - 1, 
            this.params.innerRadius, 
            64
        );
    }
    
    /**
     * Update gear materials (colors)
     */
    updateMaterials() {
        // Update pen and arm colors to match primary color
        this.penMaterial.color.set(this.params.primaryColor);
        this.penArmMaterial.color.set(this.params.primaryColor);
    }
    
    /**
     * Update gear visibility
     */
    updateVisibility() {
        this.group.visible = this.params.showGears;
        this.outerGear.visible = this.params.showGears;
        this.innerGear.visible = this.params.showGears;
        this.pen.visible = this.params.showGears;
        this.penArm.visible = this.params.showGears;
    }
    
    /**
     * Update gear positions based on current t parameter
     * @param {number} t - Current t value
     */
    updatePositions(t) {
        // Only update if gears are visible
        if (!this.params.showGears) return;
        
        // Calculate inner gear position
        const innerPos = getInnerGearPosition(t, this.params);
        this.innerGear.position.set(innerPos.x, innerPos.y, innerPos.z);
        
        // Calculate pen position
        const penPos = getSpirographPosition(t, this.params);
        this.pen.position.set(penPos.x, penPos.y, penPos.z);
        
        // Update pen arm geometry to connect inner gear and pen
        const points = [
            new Vector3(innerPos.x, innerPos.y, innerPos.z),
            new Vector3(penPos.x, penPos.y, penPos.z)
        ];
        
        if (this.penArm.geometry) {
            this.penArm.geometry.dispose();
        }
        this.penArm.geometry = new BufferGeometry().setFromPoints(points);
    }
    
    /**
     * Update gear parameters
     * @param {Object} newParams - New parameter values
     */
    updateParams(newParams) {
        // Update parameters
        Object.assign(this.params, newParams);
        
        // Update gear geometry and visibility
        this.updateGeometry();
        this.updateMaterials();
        this.updateVisibility();
    }
    
    /**
     * Toggle gear visibility
     * @param {boolean} visible - Whether gears should be visible
     */
    setVisible(visible) {
        this.params.showGears = visible;
        this.updateVisibility();
    }
    
    /**
     * Get the gear group
     * @returns {Group} Gear group
     */
    getGroup() {
        return this.group;
    }
    
    /**
     * Clean up resources
     */
    dispose() {
        this.outerGear.geometry.dispose();
        this.innerGear.geometry.dispose();
        this.pen.geometry.dispose();
        if (this.penArm.geometry) this.penArm.geometry.dispose();
        
        this.outerGear.material.dispose();
        this.innerGear.material.dispose();
        this.penMaterial.dispose();
        this.penArmMaterial.dispose();
    }
}
```
Now let's create the core engine class to coordinate everything:

```javascript:src/core/Engine.js
/**
 * Engine.js
 * Main engine that coordinates all components and handles the animation loop
 */

import { SceneManager } from '../render/Scene.js';
import { RendererManager } from '../render/Renderer.js';
import { SpirographController } from '../spirograph/SpirographController.js';
import { GearSystem } from '../gears/GearSystem.js';
import { CameraController } from '../camera/CameraController.js';

export class Engine {
    /**
     * @param {HTMLElement} container - Container element for the renderer
     */
    constructor(container) {
        // Create scene manager
        this.sceneManager = new SceneManager();
        
        // Create renderer manager
        this.rendererManager = new RendererManager(this.sceneManager, container);
        
        // Create spirograph controller
        this.spirographController = new SpirographController(this.sceneManager.getScene());
        
        // Create gear system
        this.gearSystem = new GearSystem(this.sceneManager);
        
        // Create camera controller
        this.cameraController = new CameraController(this.sceneManager, this.rendererManager);
        
        // Auto-rotation flag
        this.autoRotate = true;
        
        // Initialize animation
        this._initAnimation();
    }
    
    /**
     * Initialize animation loop
     * @private
     */
    _initAnimation() {
        // Start animation loop
        this._animate = this._animate.bind(this);
        this._animate();
    }
    
    /**
     * Animation loop
     * @private
     */
    _animate() {
        requestAnimationFrame(this._animate);
        
        // Update spirograph
        const updated = this.spirographController.update();
        
        // Get current spirograph parameter t
        const t = this.spirographController.getParams().t;
        
        // Update gear positions
        this.gearSystem.updatePositions(t);
        
        // Update camera position in rollercoaster view
        this.cameraController.update(t);
        
        // Auto-rotate the patterns if enabled and not in rollercoaster view
        if (this.autoRotate && !this.cameraController.getParams().rollercoasterView) {
            this._autoRotate();
        }
        
        // Render scene
        this.rendererManager.render();
    }
    
    /**
     * Auto-rotate the scene elements
     * @private
     */
    _autoRotate() {
        // Rotate spirograph pattern
        this.spirographController.getGroup().rotation.y += 0.001;
        
        // Rotate grid helper
        this.sceneManager.getGridHelper().rotation.y += 0.001;
        
        // Rotate gear group if visible
        if (this.gearSystem.getParams().showGears) {
            this.gearSystem.getGroup().rotation.y += 0.001;
        }
    }
    
    /**
     * Update parameters of all components
     * @param {Object} params - Parameter values to update
     */
    updateParams(params) {
        // Update spirograph parameters
        this.spirographController.updateParams(params);
        
        // Update gear system parameters
        this.gearSystem.updateParams(params);
        
        // Update camera parameters
        this.cameraController.updateParams(params);
        
        // Update auto-rotation flag
        if (params.hasOwnProperty('autoRotate')) {
            this.autoRotate = params.autoRotate;
        }
    }
    
    /**
     * Set rollercoaster view
     * @param {boolean} enabled - Whether rollercoaster view is enabled
     */
    setRollercoasterView(enabled) {
        const spirographParams = this.spirographController.getParams();
        this.cameraController.setRollercoasterView(enabled, spirographParams);
    }
    
    /**
     * Reset parameters and clear spirograph
     */
    reset() {
        this.spirographController.reset();
    }
    
    /**
     * Clear the spirograph
     */
    clear() {
        this.spirographController.clear();
    }
    
    /**
     * Handle window resize
     */
    handleResize() {
        this.rendererManager.handleResize();
    }
    
    /**
     * Clean up all resources
     */
    dispose() {
        this.spirographController.dispose();
        this.gearSystem.dispose();
        this.rendererManager.dispose();
    }
}
```
Let's implement the UI system to handle user interface interactions:

```javascript:src/ui/ControlPanel.js
/**
 * ControlPanel.js
 * Manages the UI control panel and user interactions
 */

export class ControlPanel {
    /**
     * @param {Engine} engine - The main engine
     */
    constructor(engine) {
        this.engine = engine;
        
        // Get DOM elements
        this._getElements();
        
        // Add event listeners
        this._setupEventListeners();
        
        // Initially hide camera controls
        this.cameraControlsDiv.style.display = 'none';
    }
    
    /**
     * Get all required DOM elements
     * @private
     */
    _getElements() {
        // Sliders for spirograph parameters
        this.outerRadiusInput = document.getElementById('outer-radius');
        this.innerRadiusInput = document.getElementById('inner-radius');
        this.penOffsetInput = document.getElementById('pen-offset');
        this.heightAmplitudeInput = document.getElementById('height-amplitude');
        this.speedInput = document.getElementById('speed');
        this.lineThicknessInput = document.getElementById('line-thickness');
        
        // Color pickers
        this.primaryColorInput = document.getElementById('primary-color');
        this.secondaryColorInput = document.getElementById('secondary-color');
        
        // Checkboxes
        this.showGearsCheckbox = document.getElementById('show-gears');
        this.rollercoasterViewCheckbox = document.getElementById('rollercoaster-view');
        
        // Buttons
        this.resetBtn = document.getElementById('reset-btn');
        this.clearBtn = document.getElementById('clear-btn');
        
        // Camera controls
        this.cameraControlsDiv = document.getElementById('camera-controls');
        this.cameraHeightInput = document.getElementById('camera-height');
        this.cameraDistanceInput = document.getElementById('camera-distance');
        this.cameraTiltInput = document.getElementById('camera-tilt');
        this.resetCameraBtn = document.getElementById('reset-camera-btn');
        
        // Mobile controls
        this.toggleBtn = document.getElementById('toggleControls');
        this.infoPanel = document.getElementById('info');
    }
    
    /**
     * Set up all event listeners
     * @private
     */
    _setupEventListeners() {
        // Geometry parameter inputs
        [
            this.outerRadiusInput,
            this.innerRadiusInput,
            this.penOffsetInput,
            this.heightAmplitudeInput,
            this.speedInput,
            this.lineThicknessInput
        ].forEach(input => {
            input.addEventListener('input', this._handleGeometryChange.bind(this));
        });
        
        // Color inputs
        [
            this.primaryColorInput,
            this.secondaryColorInput
        ].forEach(input => {
            input.addEventListener('input', this._handleColorChange.bind(this));
        });
        
        // Show gears checkbox
        this.showGearsCheckbox.addEventListener('change', this._handleShowGearsChange.bind(this));
        
        // Rollercoaster view checkbox
        this.rollercoasterViewCheckbox.addEventListener('change', this._handleRollercoasterViewChange.bind(this));
        
        // Camera control inputs
        [
            this.cameraHeightInput,
            this.cameraDistanceInput,
            this.cameraTiltInput
        ].forEach(input => {
            input.addEventListener('input', this._handleCameraChange.bind(this));
        });
        
        // Reset camera button
        this.resetCameraBtn.addEventListener('click', this._handleResetCamera.bind(this));
        
        // Reset and clear buttons
        this.resetBtn.addEventListener('click', () => this.engine.reset());
        this.clearBtn.addEventListener('click', () => this.engine.clear());
        
        // Mobile toggle button
        if (this.toggleBtn) {
            this.toggleBtn.addEventListener('click', this._handleTogglePanel.bind(this));
        }
        
        // Window resize
        window.addEventListener('resize', this._handleWindowResize.bind(this));
    }
    
    /**
     * Handle changes to geometry parameters
     * @private
     */
    _handleGeometryChange() {
        const params = {
            outerRadius: parseFloat(this.outerRadiusInput.value),
            innerRadius: parseFloat(this.innerRadiusInput.value),
            penOffset: parseFloat(this.penOffsetInput.value),
            heightAmplitude: parseFloat(this.heightAmplitudeInput.value),
            speed: parseFloat(this.speedInput.value),
            lineThickness: parseFloat(this.lineThicknessInput.value)
        };
        
        this.engine.updateParams(params);
    }
    
    /**
     * Handle changes to colors
     * @private
     */
    _handleColorChange() {
        const params = {
            primaryColor: this.primaryColorInput.value,
            secondaryColor: this.secondaryColorInput.value
        };
        
        this.engine.updateParams(params);
    }
    
    /**
     * Handle show gears checkbox change
     * @private
     */
    _handleShowGearsChange() {
        const params = {
            showGears: this.showGearsCheckbox.checked
        };
        
        this.engine.updateParams(params);
    }
    
    /**
     * Handle rollercoaster view checkbox change
     * @private
     */
    _handleRollercoasterViewChange() {
        const enabled = this.rollercoasterViewCheckbox.checked;
        
        // Update rollercoaster view
        this.engine.setRollercoasterView(enabled);
        
        // Show/hide camera controls
        this.cameraControlsDiv.style.display = enabled ? 'block' : 'none';
    }
    
    /**
     * Handle camera parameter changes
     * @private
     */
    _handleCameraChange() {
        const params = {
            cameraHeight: parseFloat(this.cameraHeightInput.value),
            cameraDistance: parseFloat(this.cameraDistanceInput.value),
            cameraTilt: parseFloat(this.cameraTiltInput.value)
        };
        
        this.engine.updateParams(params);
    }
    
    /**
     * Handle reset camera button click
     * @private
     */
    _handleResetCamera() {
        // Reset camera control inputs
        this.cameraHeightInput.value = "10";
        this.cameraDistanceInput.value = "0";
        this.cameraTiltInput.value = "0.2";
        
        // Update camera parameters
        this._handleCameraChange();
    }
    
    /**
     * Handle window resize
     * @private
     */
    _handleWindowResize() {
        this.engine.handleResize();
    }
    
    /**
     * Toggle control panel visibility (for mobile)
     * @private
     */
    _handleTogglePanel() {
        this.infoPanel.classList.toggle('open');
    }
    
    /**
     * Randomize spirograph parameters
     */
    randomizeParameters() {
        // Generate random values
        this.outerRadiusInput.value = Math.floor(Math.random() * (100 - 30 + 1)) + 30;
        
        // Make sure inner radius is less than outer radius
        const maxInnerRadius = Math.min(90, this.outerRadiusInput.value - 10);
        this.innerRadiusInput.value = Math.floor(Math.random() * (maxInnerRadius - 10 + 1)) + 10;
        
        // Random pen offset
        this.penOffsetInput.value = Math.floor(Math.random() * (120 - 20 + 1)) + 20;
        
        // Random height amplitude
        this.heightAmplitudeInput.value = Math.floor(Math.random() * 101);
        
        // Trigger change event
        this._handleGeometryChange();
    }
}
```
Finally, let's create the main entry point:

```javascript:src/main.js
/**
 * main.js
 * Main entry point for the application
 */

import { Engine } from './core/Engine.js';
import { ControlPanel } from './ui/ControlPanel.js';

// Wait for DOM to be loaded
document.addEventListener('DOMContentLoaded', () => {
    console.log('3D Spirograph application starting...');
    
    try {
        // Get container element
        const container = document.getElementById('container');
        if (!container) {
            throw new Error('Container element not found!');
        }
        
        // Create engine
        const engine = new Engine(container);
        
        // Create control panel
        const controlPanel = new ControlPanel(engine);
        
        // Randomize parameters to start with something interesting
        controlPanel.randomizeParameters();
        
        console.log('3D Spirograph application started successfully!');
    } catch (error) {
        console.error('Error initializing 3D Spirograph:', error);
        alert('Error initializing application. See console for details.');
    }
});
```
Now let's update the package.json file to include the necessary dependencies and module type:

```json:package.json
{
  "name": "3d-spirograph",
  "version": "1.0.0",
  "description": "An interactive 3D spirograph visualization",
  "main": "src/main.js",
  "type": "module",
  "scripts": {
    "start": "node server.js",
    "dev": "node server.js"
  },
  "dependencies": {
    "express": "^4.17.1",
    "three": "^0.140.0"
  },
  "keywords": [
    "spirograph",
    "3d",
    "visualization",
    "webgl",
    "three.js"
  ],
  "author": "",
  "license": "MIT"
}
```
Now, let's update the server.js file to serve the new modular application:

```javascript:server.js
/**
 * server.js
 * Simple Express server for local development
 */

import express from 'express';
import path from 'path';
import { fileURLToPath } from 'url';

// Get the directory name of the current module
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Create Express app
const app = express();
const PORT = process.env.PORT || 3000;

// Serve static files from the root directory
app.use(express.static(__dirname));

// Serve static files from the src directory
app.use('/src', express.static(path.join(__dirname, 'src')));

// For any other route, serve index.html
app.get('*', (req, res) => {
    res.sendFile(path.join(__dirname, 'index.html'));
});

// Start the server
app.listen(PORT, () => {
    console.log(`Server running at http://localhost:${PORT}/`);
    console.log(`Press Ctrl+C to stop the server`);
});
```

```javascript:server.js
/**
 * server.js
 * Simple Express server for local development
 */

import express from 'express';
import path from 'path';
import { fileURLToPath } from 'url';

// Get the directory name of the current module
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Create Express app
const app = express();
const PORT = process.env.PORT || 3000;

// Serve static files from the root directory
app.use(express.static(__dirname));

// Serve static files from the src directory
app.use('/src', express.static(path.join(__dirname, 'src')));

// For any other route, serve index.html
app.get('*', (req, res) => {
    res.sendFile(path.join(__dirname, 'index.html'));
});

// Start the server
app.listen(PORT, () => {
    console.log(`Server running at http://localhost:${PORT}/`);
    console.log(`Press Ctrl+C to stop the server`);
});
```

```javascript:server.js
/**
 * server.js
 * Simple Express server for local development
 */

import express from 'express';
import path from 'path';
import { fileURLToPath } from 'url';

// Get the directory name of the current module
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Create Express app
const app = express();
const PORT = process.env.PORT || 3000;

// Serve static files from the root directory
app.use(express.static(__dirname));

// Serve static files from the src directory
app.use('/src', express.static(path.join(__dirname, 'src')));

// For any other route, serve index.html
app.get('*', (req, res) => {
    res.sendFile(path.join(__dirname, 'index.html'));
});

// Start the server
app.listen(PORT, () => {
    console.log(`Server running at http://localhost:${PORT}/`);
    console.log(`Press Ctrl+C to stop the server`);
});
```

```bash
cat server.js
```
There are multiple issues with the server.js file. Let's fix it completely:

```javascript:server.js
/**
 * server.js
 * Simple Express server for local development
 */

import express from 'express';
import path from 'path';
import { fileURLToPath } from 'url';

// Get the directory name of the current module
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Create Express app
const app = express();
const PORT = process.env.PORT || 3000;

// Serve static files from the root directory
app.use(express.static(__dirname));

// Serve static files from the src directory
app.use('/src', express.static(path.join(__dirname, 'src')));

// Default route handler - send index.html for all routes
app.get('*', (req, res) => {
    res.sendFile(path.join(__dirname, 'index.html'));
});

// Start the server
app.listen(PORT, () => {
    console.log(`Server running at http://localhost:${PORT}/`);
    console.log(`Press Ctrl+C to stop the server`);
});
```

```bash
grep -r 'app.listen' server.js | wc -l
```
There are still two app.listen calls in the file. Let's fix this by completely replacing the file:

```bash

```
Let's try another approach:

Ran tool

```javascript:server.js
/**
 * server.js
 * Simple Express server for local development
 */

import express from 'express';
import path from 'path';
import { fileURLToPath } from 'url';

// Get the directory name of the current module
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Create Express app
const app = express();
const PORT = process.env.PORT || 3000;

// Serve static files from the root directory
app.use(express.static(__dirname));

// Serve static files from the src directory
app.use('/src', express.static(path.join(__dirname, 'src')));

// Default route handler - send index.html for all routes
app.get('*', (req, res) => {
    res.sendFile(path.join(__dirname, 'index.html'));
});

// Start the server
app.listen(PORT, () => {
    console.log(`Server running at http://localhost:${PORT}/`);
    console.log(`Press Ctrl+C to stop the server`);
});
```
Finally, let's create a modified index.html to work with our modular system:

```html:index.html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Spirograph</title>
    <link rel="stylesheet" href="spirograph.css">
    <style>
        /* Additional style to ensure the canvas takes full space */
        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }
        
        .github-link {
            position: fixed;
            bottom: 20px;
            left: 20px;
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 10px 15px;
            border-radius: 5px;
            text-decoration: none;
            font-family: Arial, sans-serif;
            font-size: 14px;
            display: flex;
            align-items: center;
            gap: 8px;
            transition: background-color 0.3s;
            z-index: 1000;
        }
        
        .github-link:hover {
            background-color: rgba(0, 0, 0, 0.9);
        }
        
        .github-icon {
            width: 20px;
            height: 20px;
        }
        
        /* Toggle button for controls panel */
        .toggle-controls {
            position: absolute;
            top: 10px;
            right: 10px;
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            border: none;
            border-radius: 5px;
            padding: 8px 12px;
            cursor: pointer;
            font-size: 16px;
            z-index: 1001;
            display: none; /* Hidden by default on desktop */
        }
        
        /* Media query for mobile devices */
        @media (max-width: 768px) {
            #info {
                transform: translateX(100%);
                transition: transform 0.3s ease;
            }
            
            #info.open {
                transform: translateX(0);
            }
            
            .toggle-controls {
                display: block; /* Show on mobile */
            }
        }
    </style>
</head>
<body>
    <div id="container">
        <button class="toggle-controls" id="toggleControls">☰ Settings</button>
        <div id="info">
            <h1>3D Spirograph</h1>
            <div class="controls">
                <div class="control-group">
                    <label for="outer-radius">Outer Radius:</label>
                    <input type="range" id="outer-radius" min="10" max="100" value="80" step="1">
                </div>
                <div class="control-group">
                    <label for="inner-radius">Inner Radius:</label>
                    <input type="range" id="inner-radius" min="10" max="90" value="40" step="1">
                </div>
                <div class="control-group">
                    <label for="pen-offset">Pen Offset:</label>
                    <input type="range" id="pen-offset" min="10" max="120" value="60" step="1">
                </div>
                <div class="control-group">
                    <label for="height-amplitude">3D Height:</label>
                    <input type="range" id="height-amplitude" min="0" max="100" value="30" step="1">
                </div>
                <div class="control-group">
                    <label for="speed">Speed:</label>
                    <input type="range" id="speed" min="0.1" max="5" value="1" step="0.1">
                </div>
                <div class="control-group">
                    <label for="line-thickness">Line Thickness:</label>
                    <input type="range" id="line-thickness" min="1" max="10" value="3" step="0.5">
                </div>
                <div class="color-controls">
                    <div class="control-group">
                        <label for="primary-color">Primary Color:</label>
                        <input type="color" id="primary-color" value="#ff0066">
                    </div>
                    <div class="control-group">
                        <label for="secondary-color">Secondary Color:</label>
                        <input type="color" id="secondary-color" value="#00ffcc">
                    </div>
                </div>
                <div class="control-group checkbox-group">
                    <input type="checkbox" id="show-gears">
                    <label for="show-gears">Show Gears</label>
                </div>
                <div class="control-group checkbox-group">
                    <input type="checkbox" id="rollercoaster-view">
                    <label for="rollercoaster-view">过山车视角</label>
                </div>
                <div class="control-group" id="camera-controls" style="display: none;">
                    <label for="camera-height">视角高度:</label>
                    <input type="range" id="camera-height" min="0" max="50" value="10" step="1">
                    
                    <label for="camera-distance">视角距离:</label>
                    <input type="range" id="camera-distance" min="-30" max="30" value="0" step="1">
                    
                    <label for="camera-tilt">视角倾斜:</label>
                    <input type="range" id="camera-tilt" min="0" max="1" value="0.2" step="0.05">
                    
                    <div class="buttons">
                        <button id="reset-camera-btn">复位视角</button>
                    </div>
                </div>
                <div class="buttons">
                    <button id="reset-btn">Reset</button>
                    <button id="clear-btn">Clear</button>
                </div>
            </div>
        </div>
    </div>
    
    <!-- GitHub repository link -->
    <a href="https://github.com/jankeesvw/3d-spirograph" class="github-link" target="_blank">
        <svg class="github-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="white">
            <path d="M12 0c-6.626 0-12 5.373-12 12 0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576 4.765-1.589 8.199-6.086 8.199-11.386 0-6.627-5.373-12-12-12z"/>
        </svg>
        @jankeesvw on GitHub
    </a>
    
    <!-- Import Three.js from CDN -->
    <script async src="https://cdn.jsdelivr.net/npm/three@0.140.0/build/three.min.js"></script>
    <script async src="https://cdn.jsdelivr.net/npm/three@0.140.0/examples/js/controls/OrbitControls.js"></script>
    
    <!-- Import main application script as module -->
    <script type="module" src="src/main.js"></script>
</body>
</html>
```
Now that we have set up the core modular components, let's update the imports for the OrbitControls in the renderer file:

```javascript:src/render/Renderer.js
/**
 * Renderer.js
 * Manages the WebGL renderer
 */

import { WebGLRenderer } from 'three';

export class RendererManager {
    /**
     * @param {SceneManager} sceneManager - The scene manager
     * @param {HTMLElement} container - Container element for the renderer
     */
    constructor(sceneManager, container) {
        // Store references
        this.sceneManager = sceneManager;
        this.container = container;
        
        // Create renderer
        this.renderer = new WebGLRenderer({ 
            antialias: true 
        });
        
        // Configure renderer
        this.renderer.setSize(window.innerWidth, window.innerHeight);
        this.renderer.setClearColor(0x111111); // Dark background
        
        // Add to container
        this.container.prepend(this.renderer.domElement);
        
        // Setup orbit controls - needs to wait for THREE to be fully loaded
        this.setupOrbitControls();
        
        // Handle window resize
        window.addEventListener('resize', this.handleResize.bind(this));
    }
    
    /**
     * Setup orbit controls after THREE is loaded
     */
    setupOrbitControls() {
        // Check if THREE.OrbitControls is loaded
        if (typeof THREE !== 'undefined' && THREE.OrbitControls) {
            this.setupControls();
        } else {
            // Wait for OrbitControls to be loaded
            const checkInterval = setInterval(() => {
                if (typeof THREE !== 'undefined' && THREE.OrbitControls) {
                    clearInterval(checkInterval);
                    this.setupControls();
                }
            }, 100);
        }
    }
    
    /**
     * Set up orbit controls
     */
    setupControls() {
        this.controls = new THREE.OrbitControls(
            this.sceneManager.getCamera(), 
            this.renderer.domElement
        );
        this.configureControls();
    }
    
    /**
     * Configure orbit controls
     */
    configureControls() {
        if (!this.controls) return;
        
        this.controls.enableDamping = true;
        this.controls.dampingFactor = 0.05;
    }
    
    /**
     * Handle window resize
     */
    handleResize() {
        // Update camera aspect ratio
        this.sceneManager.updateSize(window.innerWidth, window.innerHeight);
        
        // Update renderer size
        this.renderer.setSize(window.innerWidth, window.innerHeight);
    }
    
    /**
     * Enable or disable orbit controls
     * @param {boolean} enabled - Whether controls should be enabled
     */
    setControlsEnabled(enabled) {
        if (this.controls) {
            this.controls.enabled = enabled;
        }
    }
    
    /**
     * Render the scene
     */
    render() {
        // Update controls if they exist
        if (this.controls && this.controls.enabled) {
            this.controls.update();
        }
        
        // Render scene
        this.renderer.render(
            this.sceneManager.getScene(), 
            this.sceneManager.getCamera()
        );
    }
    
    /**
     * Get the renderer
     * @returns {WebGLRenderer} The renderer
     */
    getRenderer() {
        return this.renderer;
    }
    
    /**
     * Get the controls
     * @returns {OrbitControls} The orbit controls
     */
    getControls() {
        return this.controls;
    }
    
    /**
     * Clean up resources
     */
    dispose() {
        if (this.controls) {
            this.controls.dispose();
        }
        this.renderer.dispose();
    }
}
```
Let's create a simple import helper for Three.js:

```javascript:src/utils/ThreeLoader.js
/**
 * ThreeLoader.js
 * Helper to ensure Three.js is loaded before using it
 */

/**
 * Waits for Three.js to be loaded
 * @returns {Promise} Promise that resolves when Three.js is available
 */
export function waitForThree() {
    return new Promise((resolve) => {
        // If THREE is already defined, resolve immediately
        if (typeof THREE !== 'undefined') {
            resolve(THREE);
            return;
        }
        
        // Otherwise, check periodically
        const interval = setInterval(() => {
            if (typeof THREE !== 'undefined') {
                clearInterval(interval);
                resolve(THREE);
            }
        }, 100);
        
        // Set a timeout to prevent infinite waiting
        setTimeout(() => {
            clearInterval(interval);
            console.error('Timeout waiting for THREE to load');
            resolve(null);
        }, 10000);
    });
}

/**
 * Waits for a specific Three.js component to be loaded
 * @param {string} componentName - Name of the component (e.g., 'OrbitControls')
 * @returns {Promise} Promise that resolves when the component is available
 */
export function waitForThreeComponent(componentName) {
    return new Promise((resolve) => {
        // First wait for THREE to be loaded
        waitForThree().then((THREE) => {
            if (!THREE) {
                resolve(null);
                return;
            }
            
            // If component is already loaded, resolve immediately
            if (THREE[componentName]) {
                resolve(THREE[componentName]);
                return;
            }
            
            // Otherwise, check periodically
            const interval = setInterval(() => {
                if (THREE[componentName]) {
                    clearInterval(interval);
                    resolve(THREE[componentName]);
                }
            }, 100);
            
            // Set a timeout to prevent infinite waiting
            setTimeout(() => {
                clearInterval(interval);
                console.error(`Timeout waiting for THREE.${componentName} to load`);
                resolve(null);
            }, 10000);
        });
    });
}
```
Let's update the renderer to use our new ThreeLoader:

```javascript:src/render/Renderer.js
/**
 * Renderer.js
 * Manages the WebGL renderer
 */

import { waitForThree, waitForThreeComponent } from '../utils/ThreeLoader.js';

export class RendererManager {
    /**
     * @param {SceneManager} sceneManager - The scene manager
     * @param {HTMLElement} container - Container element for the renderer
     */
    constructor(sceneManager, container) {
        // Store references
        this.sceneManager = sceneManager;
        this.container = container;
        
        // Initialize renderer when Three.js is loaded
        this.initRenderer();
    }
    
    /**
     * Initialize renderer after THREE is loaded
     */
    async initRenderer() {
        // Wait for THREE to be loaded
        const THREE = await waitForThree();
        if (!THREE) {
            console.error('Failed to load THREE');
            return;
        }
        
        // Create renderer
        this.renderer = new THREE.WebGLRenderer({ 
            antialias: true 
        });
        
        // Configure renderer
        this.renderer.setSize(window.innerWidth, window.innerHeight);
        this.renderer.setClearColor(0x111111); // Dark background
        
        // Add to container
        this.container.prepend(this.renderer.domElement);
        
        // Setup orbit controls
        this.setupOrbitControls();
        
        // Handle window resize
        window.addEventListener('resize', this.handleResize.bind(this));
    }
    
    /**
     * Setup orbit controls after THREE.OrbitControls is loaded
     */
    async setupOrbitControls() {
        // Wait for OrbitControls to be loaded
        await waitForThreeComponent('OrbitControls');
        
        // Get THREE
        const THREE = await waitForThree();
        if (!THREE || !THREE.OrbitControls) {
            console.error('Failed to load OrbitControls');
            return;
        }
        
        // Create controls
        this.controls = new THREE.OrbitControls(
            this.sceneManager.getCamera(), 
            this.renderer.domElement
        );
        
        // Configure controls
        this.configureControls();
    }
    
    /**
     * Configure orbit controls
     */
    configureControls() {
        if (!this.controls) return;
        
        this.controls.enableDamping = true;
        this.controls.dampingFactor = 0.05;
    }
    
    /**
     * Handle window resize
     */
    handleResize() {
        if (!this.renderer) return;
        
        // Update camera aspect ratio
        this.sceneManager.updateSize(window.innerWidth, window.innerHeight);
        
        // Update renderer size
        this.renderer.setSize(window.innerWidth, window.innerHeight);
    }
    
    /**
     * Enable or disable orbit controls
     * @param {boolean} enabled - Whether controls should be enabled
     */
    setControlsEnabled(enabled) {
        if (this.controls) {
            this.controls.enabled = enabled;
        }
    }
    
    /**
     * Render the scene
     */
    render() {
        if (!this.renderer) return;
        
        // Update controls if they exist
        if (this.controls && this.controls.enabled) {
            this.controls.update();
        }
        
        // Render scene
        this.renderer.render(
            this.sceneManager.getScene(), 
            this.sceneManager.getCamera()
        );
    }
    
    /**
     * Get the renderer
     * @returns {WebGLRenderer} The renderer
     */
    getRenderer() {
        return this.renderer;
    }
    
    /**
     * Get the controls
     * @returns {OrbitControls} The orbit controls
     */
    getControls() {
        return this.controls;
    }
    
    /**
     * Clean up resources
     */
    dispose() {
        if (this.controls) {
            this.controls.dispose();
        }
        if (this.renderer) {
            this.renderer.dispose();
        }
    }
}
```


Let's create a README.md file to document our modular architecture:

```markdown:README.md
# 3D Spirograph

An interactive 3D spirograph visualization with modular architecture.

## Project Structure

The project is organized into modules:

- **Core**: Main engine and central coordination
- **Math**: Core mathematical equations for the spirograph
- **Render**: Scene and rendering management 
- **Spirograph**: Spirograph generation and management
- **Camera**: Camera control including rollercoaster mode
- **Gears**: Visualization of the spirograph gears
- **UI**: User interface controls
- **Utils**: Utility functions

## Getting Started

1. Clone the repository
2. Install dependencies:
   ```
   npm install
   ```
3. Start the development server:
   ```
   npm run dev
   ```
4. Open your browser at http://localhost:3000

## Future Enhancements

- Advanced recording system for creating videos
- More spirograph pattern variations
- Preset saving and sharing
- More camera modes and transitions
```
Now our modular architecture is set up! The main components have been divided into logical modules that are easier to maintain and extend. Here's a summary of what we've done:

1. Created a modular directory structure with separate modules for each major component
2. Implemented the core mathematical equations in a dedicated module
3. Created a robust model-view separation for the spirograph
4. Implemented a flexible renderer with dynamic loading of Three.js
5. Built a camera system with multiple view modes
6. Created a gear visualization system
7. Built a UI control panel that interfaces with all components
8. Implemented a core engine that coordinates all systems

This architecture allows for:

1. Better code organization and maintainability
2. Independent development of components
3. Easier addition of new features
4. Better testing capabilities
5. More collaborative development

You can continue to extend this structure by adding:

1. A preset system for saving and loading configurations
2. A recording system for creating videos
3. More spirograph variations and equations
4. Advanced visual effects
5. More camera modes and transitions

Each of these features can be implemented as separate modules without significantly changing the existing code structure.
